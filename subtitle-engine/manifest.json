{
  "id": "subtitle-engine",
  "name": "Subtitle Engine",
  "version": "1.0.0",
  "manifestURI": "https://raw.githubusercontent.com/Thekingcrusher/seanime-plugins/refs/heads/main/subtitle-engine/manifest.json",
  "language": "typescript",
  "type": "plugin",
  "description": "Add subtitles of your preferred language and format scraped from multiple different sources to your current session.",
  "author": "Thekingcrusher",
  "icon": "https://raw.githubusercontent.com/Thekingcrusher/seanime-plugins/refs/heads/main/subtitle-engine/icon.png",
  "lang": "multi",
  "payload": "/// \u003creference path=\"../../core.d.ts\" /\u003e\n/// \u003creference path=\"../../plugin.d.ts\" /\u003e\n/// \u003creference path=\"../../app.d.ts\" /\u003e\n/// \u003creference path=\"../../system.d.ts\" /\u003e\n\n//@ts-ignore\nfunction init() {\n    $ui.register((ctx) =\u003e {\n        const tray = ctx.newTray({\n            iconUrl: \"https://raw.githubusercontent.com/Thekingcrusher/seanime-plugins/refs/heads/main/subtitle-engine/icon.png\",\n            withContent: true,\n            width: \"600px\"\n        })\n\n        // --- States \u0026 Refs ---\n        const imdbId = ctx.state\u003cstring\u003e(\"\")\n        const seasonNumber = ctx.state\u003cstring\u003e(\"\")\n        const episodeNumber = ctx.state\u003cstring\u003e(\"\")\n        const subtitleResults = ctx.state\u003cany[]\u003e([])\n        const filteredSubtitleResults = ctx.state\u003cany[]\u003e([])\n        const isSearching = ctx.state\u003cboolean\u003e(false)\n        const lastSearchedKey = ctx.state\u003cstring\u003e(\"\")\n        const selectedSubUrls = ctx.state\u003cstring[]\u003e([])\n        const activeSession = ctx.state\u003cboolean\u003e(false)\n        const autoSelected = ctx.state\u003cboolean\u003e(false)\n\n        const imdbRef = ctx.fieldRef()\n        const seasonRef = ctx.fieldRef()\n        const episodeRef = ctx.fieldRef()\n        const langRef = ctx.fieldRef\u003cstring\u003e($getUserPreference(\"language\"))\n        const sourceRef = ctx.fieldRef\u003cstring\u003e($getUserPreference(\"source\"))\n        const formatRef = ctx.fieldRef\u003cstring\u003e($getUserPreference(\"format\"))\n        \n        const hiRef = ctx.fieldRef\u003cboolean\u003e(false)\n        const savedHi = $getUserPreference(\"hi\")\n        hiRef.setValue(savedHi === \"true\")\n        const signRef = ctx.fieldRef\u003cboolean\u003e(false)\n        const savedSign = $getUserPreference(\"signSong\")\n        signRef.setValue(savedSign === \"true\")\n        const honorRef = ctx.fieldRef\u003cboolean\u003e(false)\n        const savedHonor = $getUserPreference(\"honorifics\")\n        honorRef.setValue(savedHonor === \"true\")\n\n        async function injectSubtitle(sub: any) {\n            try {\n                const data = $habari.parse(sub.media);\n                const label = `${data.release_group ? `[${data.release_group}] ` : ``}${sub.display}${sub.isHearingImpaired ? \" [CC]\" : \"\"}${sub.isSignSong ? \" [Sign/Song]\" : \"\"}${sub.isHonorifics ? \" [Honorifics]\" : \"\"} (${sub.format.toUpperCase()})`\n\n                ctx.videoCore.addExternalSubtitleTrack({\n                    src: sub.url,\n                    label,\n                    language: sub.language,\n                    type: sub.format.toLowerCase(),\n                });\n                \n                selectedSubUrls.set([...selectedSubUrls.get(), sub.url]);\n            } catch (err) {\n                ctx.toast.error(\"Failed to inject subtitle\", err);\n                console.log(err)\n            }\n        }\n\n        async function loadMediaData(anilistId: number) {\n            try {\n                const metadata = await ctx.anime.getAnimeMetadata(\"anilist\", anilistId)\n                const info = ctx.videoCore.getCurrentPlaybackInfo();\n                const mappingImdb = metadata.mappings?.imdbId?.toString();\n                const mappingTmdb = metadata.mappings?.themoviedbId?.toString();\n                const currentSeason = metadata.episodes[\"1\"]?.seasonNumber?.toString();\n                const currentEpisode = info.episode?.episodeNumber?.toString();\n                const eid = metadata.episodes[currentEpisode]?.anidbId?.toString();\n                const currentFormat = info.media?.format?.toUpperCase();\n\n                if (sourceRef.current === \"animetoshoSource\") {\n                    await fetchAnimeTosho(eid);\n                    let results = filteredSubtitleResults.get();\n                  \n                    if (results.length === 0 \u0026\u0026 formatRef.current !== \"all\" \u0026\u0026 $getUserPreference(\"autoSelect\") === \"smart\" \u0026\u0026 !autoSelected.get()) {\n                        formatRef.setValue(\"all\");\n                        applyFilters();\n                        results = filteredSubtitleResults.get();\n                    }\n                    if (results.length === 0 \u0026\u0026 hiRef.current \u0026\u0026 $getUserPreference(\"autoSelect\") === \"smart\" \u0026\u0026 !autoSelected.get()) {\n                        hiRef.setValue(false);\n                        applyFilters();\n                        results = filteredSubtitleResults.get();\n                    }\n                    if (results.length === 0 \u0026\u0026 signRef.current \u0026\u0026 $getUserPreference(\"autoSelect\") === \"smart\" \u0026\u0026 !autoSelected.get()) {\n                        signRef.setValue(false);\n                        applyFilters();\n                        results = filteredSubtitleResults.get();\n                    }\n                    if (results.length === 0 \u0026\u0026 honorRef.current \u0026\u0026 $getUserPreference(\"autoSelect\") === \"smart\" \u0026\u0026 !autoSelected.get()) {\n                        honorRef.setValue(false);\n                        applyFilters();\n                        results = filteredSubtitleResults.get();\n                    }\n                    if ($getUserPreference(\"autoSelect\") !== \"none\" \u0026\u0026 !autoSelected.get()) {\n                        if (results.length \u003e 0) {\n                            await injectSubtitle(results[0]);\n                            autoSelected.set(true);\n                        } else {\n                            const type = $getUserPreference(\"autoSelect\") === \"auto\" ? \"Auto\" : \"Smart\";\n                            ctx.toast.warning(`${type} Select could not find any subtitles`);\n                            autoSelected.set(true);\n                        }\n                    }\n                    return\n                }\n\n                const bestId = mappingTmdb || mappingImdb;\n                const fallback = !bestId || !currentSeason;\n                const method = $getUserPreference(\"method\");\n    \n                if (bestId) {\n                    imdbId.set(bestId);\n                    imdbRef.setValue(bestId);\n                }\n\n                if (currentSeason !== \"0\") {\n                  seasonNumber.set(currentSeason);\n                  seasonRef.setValue(currentSeason);\n                  episodeNumber.set(currentEpisode);\n                  episodeRef.setValue(currentEpisode);\n                }\n        \n                if (fallback \u0026\u0026 currentFormat !== \"MOVIE\") {\n                    console.log(`Metadata missing IDs, falling back to ID mapping method ${method}.`);\n                    \n                    if (method === \"1\") {\n                        const anidbId = metadata.mappings.anidbId;\n                        const res = await fetch(\"https://raw.githubusercontent.com/Anime-Lists/anime-lists/refs/heads/master/anime-list-full.xml\");\n                        const xmlText = await res.text();\n                        const $ = LoadDoc(xmlText);\n                        const animeNode = $(`anime[anidbid=\"${anidbId}\"]`);\n    \n                        if (animeNode.length) {\n                            const tmdbId = animeNode.attr(\"tmdbtv\");\n                            const tmdbSeason = animeNode.attr(\"defaulttvdbseason\");\n                            if (tmdbId) { imdbId.set(tmdbId); imdbRef.setValue(tmdbId); }\n                            if (tmdbSeason !== \"0\") { seasonNumber.set(tmdbSeason); seasonRef.setValue(tmdbSeason); episodeNumber.set(currentEpisode); episodeRef.setValue(currentEpisode); }\n                        }\n                    } else if (method === \"2\") {\n                        const res = await fetch(`https://ramregar97-idmapper.hf.space/api/mapper?anilist_id=${anilistId}`);\n                        const data = await res.json();\n                        imdbId.set(data.tmdb_show_id?.toString() || data.themoviedb_id?.toString() || data.imdb_id?.toString());\n                        imdbRef.setValue(data.tmdb_show_id?.toString() || data.themoviedb_id?.toString() || data.imdb_id?.toString());\n                        const keys = data.tvdb_mappings ? Object.keys(data.tvdb_mappings) : [];\n                        if (keys.length \u003e 0) {\n                            const sNum = keys[0].replace(\"s\", \"\");\n                            if (sNum !== \"0\") {\n                                seasonNumber.set(sNum);\n                                seasonRef.setValue(sNum);\n                                episodeNumber.set(currentEpisode);\n                                episodeRef.setValue(currentEpisode);\n                            }\n                        }\n                    }\n                }\n\n                if (!bestId \u0026\u0026 currentFormat === \"MOVIE\") {\n                    console.log(`Metadata missing IDs, falling back to ID mapping movie method ${method}.`);\n                    \n                    if (method === \"1\") {\n                        const anidbId = metadata.mappings.anidbId;\n                        const res = await fetch(\"https://raw.githubusercontent.com/Anime-Lists/anime-lists/refs/heads/master/anime-list-full.xml\");\n                        const xmlText = await res.text();\n                        const $ = LoadDoc(xmlText);\n                        const animeNode = $(`anime[anidbid=\"${anidbId}\"]`);\n    \n                        if (animeNode.length) {\n                            const tmdbId = animeNode.attr(\"tmdbid\");\n                            const imdbid = animeNode.attr(\"imdbid\");\n                            const tmdbSeason = animeNode.attr(\"defaulttvdbseason\");\n                            imdbId.set(tmdbId || imdbid);\n                            imdbRef.setValue(tmdbId || imdbid);\n                            if (tmdbSeason !== \"0\") { seasonNumber.set(tmdbSeason); seasonRef.setValue(tmdbSeason); episodeNumber.set(currentEpisode); episodeRef.setValue(currentEpisode); }\n                        }\n                    } else if (method === \"2\") {\n                        const res = await fetch(`https://ramregar97-idmapper.hf.space/api/mapper?anilist_id=${anilistId}`);\n                        const data = await res.json();\n                        imdbId.set(data.tmdb_movie_id?.toString() || data.themoviedb_id?.toString() || data.imdb_id?.toString());\n                        imdbRef.setValue(data.tmdb_movie_id?.toString() || data.themoviedb_id?.toString() || data.imdb_id?.toString());\n                        const keys = data.tvdb_mappings ? Object.keys(data.tvdb_mappings) : [];\n                        if (keys.length \u003e 0) {\n                            const sNum = keys[0].replace(\"s\", \"\");\n                            if (sNum !== \"0\") {\n                                seasonNumber.set(sNum);\n                                seasonRef.setValue(sNum);\n                                episodeNumber.set(currentEpisode);\n                                episodeRef.setValue(currentEpisode); \n                            }\n                        }\n                    }\n                }\n\n                tray.update();\n                  \n                if (imdbRef.current) {\n                    await fetchSubtitles(true);\n                    let results = subtitleResults.get();\n                  \n                    if (results.length === 0 \u0026\u0026 formatRef.current !== \"all\" \u0026\u0026 $getUserPreference(\"autoSelect\") === \"smart\" \u0026\u0026 !autoSelected.get()) {\n                        await fetchSubtitles(true, { format: \"all\" });\n                        results = subtitleResults.get();\n                    }\n                    if (results.length === 0 \u0026\u0026 hiRef.current \u0026\u0026 $getUserPreference(\"autoSelect\") === \"smart\" \u0026\u0026 !autoSelected.get()) {\n                        await fetchSubtitles(true, { format: \"all\", hi: false });\n                        results = subtitleResults.get();\n                    }\n                    if ($getUserPreference(\"autoSelect\") !== \"none\" \u0026\u0026 !autoSelected.get()) {\n                        if (results.length \u003e 0) {\n                            await injectSubtitle(results[0]);\n                            autoSelected.set(true);\n                        } else {\n                            const type = $getUserPreference(\"autoSelect\") === \"auto\" ? \"Auto\" : \"Smart\";\n                            ctx.toast.warning(`${type} Select could not find any subtitles`);\n                            autoSelected.set(true);\n                        }\n                    }\n                }\n            } catch (e) {\n                console.error(\"Mapping error\", e);\n            }\n        }\n\n        async function fetchAnimeTosho(eid: number) {\n            if (lastSearchedKey.get() === eid) return;\n            isSearching.set(true);\n            tray.update();\n        \n            try {\n                const url = `https://feed.animetosho.org/json?eid=${eid}`;\n                const res = await fetch(url);\n                const allEntries = await res.json();\n        \n                // 1. Resolution Value Helper\n                const getResValue = (title: string): number =\u003e {\n                    if (/\\b2160p\\b|\\b4k\\b/i.test(title)) return 2160;\n                    if (/\\b1440p\\b|\\b2k\\b/i.test(title)) return 1440;\n                    if (/\\b1080p\\b/i.test(title)) return 1080;\n                    if (/\\b720p\\b/i.test(title)) return 720;\n                    if (/\\b480p\\b/i.test(title)) return 480;\n                    return 0;\n                };\n        \n                // 2. DEDUPLICATION: Group by normalized title, pick highest resolution\n                const groups: Record\u003cstring, any[]\u003e = {};\n                allEntries.forEach((entry: any) =\u003e {\n                    if (entry.title.toLowerCase().includes(\"batch\")) return;\n        \n                    const normalizedTitle = entry.title\n                        .replace(/\\b\\d{3,4}p\\b/gi, \"\")\n                        .replace(/\\b4k\\b|\\b2k\\b/gi, \"\")\n                        .replace(/\\b(?:avc|hevc|x264|x265|h\\.264|h\\.265)\\b/gi, \"\")\n                        .replace(/\\b(?:aac|flac|opus|mp3|dolby|truehd|dts(?:-hd)?(?:\\sma)?)\\b/gi, \"\")\n                        .replace(/[\\[\\(][0-9A-F]{8}[\\]\\)]/gi, \"\")\n                        .replace(/\\s+/g, \" \")\n                        .trim();\n        \n                    if (!groups[normalizedTitle]) groups[normalizedTitle] = [];\n                    groups[normalizedTitle].push(entry);\n                });\n        \n                const entries = Object.values(groups).map(group =\u003e {\n                    return group.sort((a, b) =\u003e getResValue(b.title) - getResValue(a.title))[0];\n                });\n        \n                // 3. CONCURRENCY \u0026 RETRY LOGIC\n                // Limit max speed to 12. 25 is too high and triggers browser/API bottlenecks.\n                const speedPref = $getUserPreference(\"speed\") === \"veryfast\" || $getUserPreference(\"speed\") === \"fast\";\n                const CONCURRENCY_LIMIT = speedPref ? 12 : 5;\n                \n                const allTorrents: any[] = [];\n                let index = 0;\n        \n                const fetchWithRetry = async (id: number, retries = 2): Promise\u003cany\u003e =\u003e {\n                    try {\n                        const tRes = await fetch(`https://feed.animetosho.org/json?show=torrent\u0026id=${id}`);\n                        \n                        // If Rate Limited (429), wait and retry\n                        if (tRes.status === 429 \u0026\u0026 $getUserPreference(\"speed\") === \"fast\" \u0026\u0026 retries \u003e 0) {\n                            await new Promise(r =\u003e ctx.setTimeout(r, 1500));\n                            return fetchWithRetry(id, retries - 1);\n                        }\n                        \n                        if (!tRes.ok) return null;\n                        return await tRes.json();\n                    } catch (e) {\n                        if (retries \u003e 0) {\n                            await new Promise(r =\u003e ctx.setTimeout(r, 1000));\n                            return fetchWithRetry(id, retries - 1);\n                        }\n                        return null;\n                    }\n                };\n        \n                const worker = async () =\u003e {\n                    while (index \u003c entries.length) {\n                        const entry = entries[index++];\n                        const data = await fetchWithRetry(entry.id);\n                        if (data) allTorrents.push(data);\n                    }\n                };\n        \n                // Start the worker pool\n                await Promise.all(\n                    Array(Math.min(CONCURRENCY_LIMIT, entries.length))\n                        .fill(null)\n                        .map(() =\u003e worker())\n                );\n        \n                // 4. DATA TRANSFORMATION\n                let results: any[] = [];\n                for (const torrent of allTorrents) {\n                    if (!torrent?.files) continue;\n                    for (const file of torrent.files) {\n                        if (!file.attachments) continue;\n                        for (const attach of file.attachments) {\n                            if (attach.type !== \"subtitle\") continue;\n        \n                            const providers = detectProvider(attach.info?.name);\n                            const langInfo = resolveLanguage(attach.info?.lang);\n                            \n                            let language = langInfo.iso2;\n                            let flag = langInfo.countryCode;\n                            const context = (torrent.title + (attach.info?.name || \"\")).toLowerCase();\n        \n                            // Language tagging logic\n                            if (langInfo.iso2 === \"pt\" \u0026\u0026 /brazil|\\bbr\\b/i.test(context)) {\n                                flag = \"BR\"; language = \"pb\";\n                            }\n                            if (langInfo.iso2 === \"zh\" \u0026\u0026 /(hong kong|\\bzt\\b|traditional)/i.test(context)) {\n                                language = \"zt\";\n                            }\n                            if (langInfo.iso2 === \"es\" \u0026\u0026 /latin america|\\bla\\b|\\blatam\\b/i.test(context)) {\n                                language = \"la\";\n                            }\n        \n                            results.push({\n                                release: torrent.title,\n                                display: langInfo.cleanName,\n                                language,\n                                format: attach.info?.codec,\n                                url: `https://sub.wyzie.ru/c/animetosho/id/${attach.id}.animetosho?format=${attach.info?.codec?.toLowerCase()}`,\n                                source: \"animetosho\",\n                                isCR: providers.isCR,\n                                isNF: providers.isNF,\n                                isHearingImpaired: /\\b(cc|closed? captions?|hi|sdh|hearing impaired)\\b/i.test(attach.info?.name || \"\"),\n                                isSignSongs: /\\b(signs?|songs?|sign(?:[-_/ ]+)songs?)\\b/i.test(attach.info?.name || \"\"),\n                                isHonorifics: /honorific/i.test(attach.info?.name),\n                                flagUrl: `https://flagsapi.com/${flag}/flat/64.png`, \n                                media: torrent.title\n                            });\n                        }\n                    }\n                }\n        \n                subtitleResults.set(results);\n                applyFilters();\n                lastSearchedKey.set(eid);\n        \n            } catch (err) {\n                ctx.toast.error(\"AnimeTosho search failed\");\n                console.error(err);\n            } finally {\n                isSearching.set(false);\n            }\n        }\n\n        async function fetchSubtitles(isAuto = false, overrides = {}) {\n            const id = imdbRef.current || imdbId.get();\n            const s = seasonRef.current || seasonNumber.get();\n            const ep = episodeRef.current || episodeNumber.get();\n            const source = overrides.source || sourceRef.current;\n            const format = overrides.format || formatRef.current;\n            const lang = overrides.lang || langRef.current;\n            const hi = overrides.hi !== undefined ? overrides.hi : hiRef.current;\n            if (!id) {\n              ctx.toast.warning(\"IMDB/TMDB ID not found\")\n              return\n            }\n\n            const currentKey = `${id}-${s}-${ep}-${source}-${format}-${lang}-${hi}`;\n            if (isAuto \u0026\u0026 lastSearchedKey.get() === currentKey) return;\n\n            isSearching.set(true);\n            try {\n                let url = `https://sub.wyzie.ru/search?id=${id}`;\n                if (s \u0026\u0026 ep) url += `\u0026season=${s}\u0026episode=${ep}`;\n                if (source !== \"opensubtitles\") url += `\u0026source=${source}`;\n                if (format !== \"all\") url += `\u0026format=${format}`;\n                if (lang !== \"all\") url += `\u0026language=${lang}`;\n                if (hi) url += `\u0026isHearingImpaired=true`;\n\n                const res = await fetch(url);\n                const data = await res.json();\n                subtitleResults.set(Array.isArray(data) ? data : []);\n                applyFilters();\n                lastSearchedKey.set(currentKey);\n            } catch (err) {\n                ctx.toast.error(\"Subtitle search failed\");\n            } finally {\n                isSearching.set(false);\n            }\n        }\n      \n        function detectProvider(name: string = \"\") {\n          return {\n            isCR: /\\(?CR\\b|Crunchyroll/i.test(name),\n            isNF: /\\(?NF\\b|Netflix/i.test(name)\n          };\n        }\n\n        function resolveLanguage(rawLang: string = \"und\") {\n            const code = rawLang.toLowerCase().trim();\n        \n            // 2. Map 3-letter (AnimeTosho) to 2-letter (ISO 639-1)\n            const toAlpha2: Record\u003cstring, string\u003e = {\n                \"ara\": \"ar\", \"chi\": \"zh\", \"zho\": \"zh\", \"fre\": \"fr\", \"fra\": \"fr\",\n                \"ger\": \"de\", \"deu\": \"de\", \"ind\": \"id\", \"ita\": \"it\", \"jpn\": \"ja\",\n                \"kor\": \"ko\", \"may\": \"ms\", \"msa\": \"ms\", \"por\": \"pt\", \"rus\": \"ru\",\n                \"spa\": \"es\", \"tha\": \"th\", \"vie\": \"vi\", \"eng\": \"en\"\n            };\n            \n            const iso2 = toAlpha2[code] || (code.length === 2 ? code : \"en\");\n        \n            // 3. Complete Country Code Map (Wyzie Sub)\n            const countryMap: Record\u003cstring, string\u003e = {\n                af: \"ZA\", ak: \"GH\", ar: \"SA\", az: \"AZ\", be: \"BY\", bg: \"BG\", bn: \"BD\", bs: \"BA\", ca: \"ES\", cs: \"CZ\", da: \"DK\", de: \"DE\", el: \"GR\", en: \"US\", eo: \"PL\", es: \"ES\", et: \"EE\", fa: \"IR\", fi: \"FI\", fr: \"FR\", ga: \"IE\", gd: \"GB\", he: \"IL\", hi: \"IN\", hr: \"HR\", hu: \"HU\", hy: \"AM\", id: \"ID\", is: \"IS\", it: \"IT\", ja: \"JP\", ka: \"GE\", kk: \"KZ\", ko: \"KR\", lt: \"LT\", lv: \"LV\", mk: \"MK\", mn: \"MN\", ms: \"MY\", nb: \"NO\", nl: \"NL\", nn: \"NO\", no: \"NO\", pl: \"PL\", pt: \"PT\", ro: \"RO\", ru: \"RU\", sk: \"SK\", sl: \"SI\", sq: \"AL\", sr: \"RS\", sv: \"SE\", th: \"TH\", tr: \"TR\", uk: \"UA\", vi: \"VN\", zh: \"CN\", ze: \"CN\", zt: \"CN\", am: \"ET\", eu: \"ES\", gl: \"ES\", gu: \"IN\", ha: \"NG\", ig: \"NG\", iw: \"IL\", jv: \"ID\", km: \"KH\", kn: \"IN\", ky: \"KG\", lo: \"LA\", mg: \"MG\", ml: \"IN\", mr: \"IN\", my: \"MM\", ne: \"NP\", om: \"ET\", or: \"IN\", pa: \"IN\", ps: \"AF\", si: \"LK\", so: \"SO\", sw: \"TZ\", ta: \"IN\", te: \"IN\", tg: \"TJ\", tk: \"TM\", ur: \"PK\", uz: \"UZ\", yo: \"NG\", zu: \"ZA\", as: \"IN\", ay: \"BO\", bh: \"IN\", bi: \"VU\", br: \"FR\", ch: \"GU\", co: \"FR\", cr: \"CA\", cy: \"GB\", dv: \"MV\", ee: \"GH\", fj: \"FJ\", fo: \"FO\", ff: \"SN\", gn: \"PY\", ht: \"HT\", hz: \"NA\", ia: \"FR\", ie: \"FR\", ik: \"US\", kl: \"GL\", ki: \"KE\", kj: \"AO\", ku: \"IQ\", lb: \"LU\", lg: \"UG\", ln: \"CD\", lu: \"CD\", mh: \"MH\", na: \"NR\", nd: \"ZW\", ng: \"NA\", nr: \"ZA\", nv: \"US\", ny: \"MW\", oc: \"FR\", oj: \"CA\", os: \"RU\", pi: \"IN\", qu: \"PE\", rn: \"BI\", rw: \"RW\", sa: \"IN\", sc: \"IT\", sd: \"PK\", sg: \"CF\", sm: \"WS\", sn: \"ZW\", ss: \"SZ\", st: \"LS\", su: \"ID\", tl: \"PH\", tn: \"BW\", ts: \"ZA\", tt: \"RU\", tw: \"GH\", ty: \"PF\", ug: \"CN\", ve: \"ZA\", vo: \"DE\", wa: \"BE\", wo: \"SN\", xh: \"ZA\", yi: \"IL\", za: \"CN\"\n            };\n        \n            // 4. Complete Metadata Map (SubDL)\n            const metaMap: Record\u003cstring, {name: string}\u003e = {\n                ab: { name: \"Abkhaz\" }, aa: { name: \"Afar\" }, af: { name: \"Afrikaans\" }, ak: { name: \"Akan\" }, sq: { name: \"Albanian\" }, am: { name: \"Amharic\" }, ar: { name: \"Arabic\" }, an: { name: \"Aragonese\" }, hy: { name: \"Armenian\" }, as: { name: \"Assamese\" }, av: { name: \"Avaric\" }, ae: { name: \"Avestan\" }, ay: { name: \"Aymara\" }, az: { name: \"Azerbaijani\" }, bm: { name: \"Bambara\" }, ba: { name: \"Bashkir\" }, eu: { name: \"Basque\" }, be: { name: \"Belarusian\" }, bn: { name: \"Bengali\" }, bh: { name: \"Bihari\" }, bi: { name: \"Bislama\" }, bs: { name: \"Bosnian\" }, br: { name: \"Breton\" }, bg: { name: \"Bulgarian\" }, my: { name: \"Burmese\" }, ca: { name: \"Catalan\" }, ch: { name: \"Chamorro\" }, ce: { name: \"Chechen\" }, ny: { name: \"Chichewa\" }, zh: { name: \"Chinese\" }, cv: { name: \"Chuvash\" }, kw: { name: \"Cornish\" }, co: { name: \"Corsican\" }, cr: { name: \"Cree\" }, hr: { name: \"Croatian\" }, cs: { name: \"Czech\" }, da: { name: \"Danish\" }, dv: { name: \"Divehi\" }, nl: { name: \"Dutch\" }, en: { name: \"English\" }, eo: { name: \"Esperanto\" }, et: { name: \"Estonian\" }, ee: { name: \"Ewe\" }, fo: { name: \"Faroese\" }, fj: { name: \"Fijian\" }, fi: { name: \"Finnish\" }, fr: { name: \"French\" }, ff: { name: \"Fula\" }, gl: { name: \"Galician\" }, ka: { name: \"Georgian\" }, de: { name: \"German\" }, el: { name: \"Greek\" }, gn: { name: \"Guaraní\" }, gu: { name: \"Gujarati\" }, ht: { name: \"Haitian\" }, ha: { name: \"Hausa\" }, he: { name: \"Hebrew\" }, hz: { name: \"Herero\" }, hi: { name: \"Hindi\" }, ho: { name: \"Hiri Motu\" }, hu: { name: \"Hungarian\" }, ia: { name: \"Interlingua\" }, id: { name: \"Indonesian\" }, ga: { name: \"Irish\" }, ig: { name: \"Igbo\" }, ik: { name: \"Inupiaq\" }, io: { name: \"Ido\" }, is: { name: \"Icelandic\" }, it: { name: \"Italian\" }, iu: { name: \"Inuktitut\" }, ja: { name: \"Japanese\" }, jv: { name: \"Javanese\" }, kl: { name: \"Greenlandic\" }, kn: { name: \"Kannada\" }, kr: { name: \"Kanuri\" }, ks: { name: \"Kashmiri\" }, kk: { name: \"Kazakh\" }, km: { name: \"Khmer\" }, ki: { name: \"Kikuyu\" }, rw: { name: \"Kinyarwanda\" }, ky: { name: \"Kirghiz\" }, kv: { name: \"Komi\" }, kg: { name: \"Kongo\" }, ko: { name: \"Korean\" }, ku: { name: \"Kurdish\" }, kj: { name: \"Kwanyama\" }, la: { name: \"Latin\" }, lb: { name: \"Luxembourgish\" }, lg: { name: \"Luganda\" }, li: { name: \"Limburgish\" }, ln: { name: \"Lingala\" }, lo: { name: \"Lao\" }, lt: { name: \"Lithuanian\" }, lu: { name: \"Luba-Katanga\" }, lv: { name: \"Latvian\" }, gv: { name: \"Manx\" }, mk: { name: \"Macedonian\" }, mg: { name: \"Malagasy\" }, ms: { name: \"Malay\" }, ml: { name: \"Malayalam\" }, mt: { name: \"Maltese\" }, mi: { name: \"Māori\" }, mr: { name: \"Marathi\" }, mh: { name: \"Marshallese\" }, mn: { name: \"Mongolian\" }, na: { name: \"Nauru\" }, nv: { name: \"Navajo\" }, nb: { name: \"Norwegian Bokmål\" }, nd: { name: \"North Ndebele\" }, ne: { name: \"Nepali\" }, ng: { name: \"Ndonga\" }, nn: { name: \"Norwegian Nynorsk\" }, no: { name: \"Norwegian\" }, ii: { name: \"Nuosu\" }, nr: { name: \"South Ndebele\" }, oc: { name: \"Occitan\" }, oj: { name: \"Ojibwe\" }, om: { name: \"Oromo\" }, or: { name: \"Oriya\" }, os: { name: \"Ossetian\" }, pa: { name: \"Panjabi\" }, pi: { name: \"Pāli\" }, fa: { name: \"Persian\" }, pl: { name: \"Polish\" }, ps: { name: \"Pashto\" }, pt: { name: \"Portuguese\" }, qu: { name: \"Quechua\" }, rm: { name: \"Romansh\" }, rn: { name: \"Kirundi\" }, ro: { name: \"Romanian\" }, ru: { name: \"Russian\" }, sa: { name: \"Sanskrit\" }, sc: { name: \"Sardinian\" }, sd: { name: \"Sindhi\" }, se: { name: \"Northern Sami\" }, sm: { name: \"Samoan\" }, sg: { name: \"Sango\" }, sr: { name: \"Serbian\" }, gd: { name: \"Scottish Gaelic\" }, sn: { name: \"Shona\" }, si: { name: \"Sinhala\" }, sk: { name: \"Slovak\" }, sl: { name: \"Slovene\" }, so: { name: \"Somali\" }, st: { name: \"Southern Sotho\" }, es: { name: \"Spanish\" }, su: { name: \"Sundanese\" }, sw: { name: \"Swahili\" }, ss: { name: \"Swati\" }, sv: { name: \"Swedish\" }, ta: { name: \"Tamil\" }, te: { name: \"Telugu\" }, tg: { name: \"Tajik\" }, th: { name: \"Thai\" }, ti: { name: \"Tigrinya\" }, bo: { name: \"Tibetan\" }, tk: { name: \"Turkmen\" }, tl: { name: \"Tagalog\" }, tn: { name: \"Tswana\" }, to: { name: \"Tonga\" }, tr: { name: \"Turkish\" }, ts: { name: \"Tsonga\" }, tt: { name: \"Tatar\" }, tw: { name: \"Twi\" }, ty: { name: \"Tahitian\" }, ug: { name: \"Uighur\" }, uk: { name: \"Ukrainian\" }, ur: { name: \"Urdu\" }, uz: { name: \"Uzbek\" }, ve: { name: \"Venda\" }, vi: { name: \"Vietnamese\" }, vo: { name: \"Volapük\" }, wa: { name: \"Walloon\" }, cy: { name: \"Welsh\" }, wo: { name: \"Wolof\" }, fy: { name: \"Western Frisian\" }, xh: { name: \"Xhosa\" }, yi: { name: \"Yiddish\" }, yo: { name: \"Yoruba\" }, za: { name: \"Zhuang\" }, pb: { name: \"Portuguese (Brazil)\" }, ze: { name: \"Chinese (Simplified)\" }, zt: { name: \"Chinese (Traditional)\" }, iw: { name: \"Hebrew\" }\n            };\n        \n            return {\n                iso2: iso2,\n                countryCode: countryMap[iso2] || \"US\",\n                cleanName: metaMap[iso2]?.name || displayName.split('(')[0].trim()\n            };\n        }\n\n        function applyFilters() {\n            let filteredSubs = [...subtitleResults.get()];\n            const format = formatRef.current;\n            const lang = langRef.current;\n            const hi = hiRef.current;\n            const sign = signRef.current;\n            const honor = honorRef.current;\n        \n            if (format \u0026\u0026 format !== \"all\") {\n                filteredSubs = filteredSubs.filter(sub =\u003e sub.format.toLowerCase() === format.toLowerCase());\n            }\n        \n            if (lang \u0026\u0026 lang !== \"all\") {\n                if (sourceRef.current === \"animetoshoSource\" \u0026\u0026 lang === \"ea\") {\n                    filteredSubs = filteredSubs.filter(sub =\u003e sub.language === \"la\");\n                }\n                else { filteredSubs = filteredSubs.filter(sub =\u003e sub.language === lang); }\n            }\n        \n            if (hi) {\n                filteredSubs = filteredSubs.filter(sub =\u003e sub.isHearingImpaired === true);\n            }\n        \n            if (sign) {\n                filteredSubs = filteredSubs.filter(sub =\u003e sub.isSignSongs === true);\n            }\n        \n            if (honor) {\n                filteredSubs = filteredSubs.filter(sub =\u003e sub.isHonorifics === true);\n            }\n        \n            filteredSubtitleResults.set(filteredSubs);\n        }\n\n        ctx.registerEventHandler(\"filter\", () =\u003e {\n            ctx.setTimeout(() =\u003e {\n                applyFilters();\n            }, 50);\n        });\n        \n        ctx.registerEventHandler(\"update\", () =\u003e {\n            ctx.setTimeout(() =\u003e {\n                const info = ctx.videoCore.getCurrentPlaybackInfo();\n                if (info) {\n                    loadMediaData(parseInt(info.media.id));\n                } else {\n                    ctx.videoCore.addEventListener(\"video-loaded\", (event) =\u003e {\n                        const info = ctx.videoCore.getCurrentPlaybackInfo();\n                        loadMediaData(parseInt(info.media.id));\n                    })\n                }\n                tray.update();\n            }, 50);\n        });\n\n        ctx.registerEventHandler(\"triggerManualSearch\", () =\u003e {\n            const id = imdbRef.current;\n            const s = seasonRef.current;\n            const e = episodeRef.current;\n          \n            if (!id) return ctx.toast.warning(\"IMDB/TMDB ID is required\");\n            if (s \u0026\u0026 !e) return ctx.toast.warning(\"Episode number required\");\n            if (!s \u0026\u0026 e) return ctx.toast.warning(\"Season number required\");\n\n            if (activeSession.get()) {\n                fetchSubtitles(false);\n            }\n        });\n        \n        ctx.screen.onNavigate(async (e) =\u003e {\n            if (e.pathname === \"/entry\" \u0026\u0026 e.searchParams.id) {\n                activeSession.set(true);\n                selectedSubUrls.set([]);\n                langRef.setValue($getUserPreference(\"language\"));\n                sourceRef.setValue($getUserPreference(\"source\"));\n                formatRef.setValue($getUserPreference(\"format\"));\n                if ($getUserPreference(\"autoSelect\") !== \"none\") {\n                    ctx.videoCore.addEventListener(\"video-loaded\", () =\u003e loadMediaData(parseInt(e.searchParams.id)));\n                }\n            }\n            else activeSession.set(false)\n        });\n\n        tray.onOpen(() =\u003e {\n            if (activeSession.get()) {\n                const info = ctx.videoCore.getCurrentPlaybackInfo();\n                if (info) {\n                    loadMediaData(parseInt(info.media.id));\n                } else {\n                    ctx.videoCore.addEventListener(\"video-loaded\", (event) =\u003e {\n                        const info = ctx.videoCore.getCurrentPlaybackInfo();\n                        loadMediaData(parseInt(info.media.id));\n                    });\n                }\n              \n            }\n        })\n\n        tray.render(() =\u003e {\n            const subs = filteredSubtitleResults.get() || [];\n            const currentlySelectedList = selectedSubUrls.get() || [];\n            const integrated = sourceRef.current === \"animetoshoSource\";\n\n            return tray.div([\n                tray.css(`                 \n                    .subtitle-item { transition: all 0.3s ease !important; margin: 0 8px; border-radius: 8px !important; }\n                    .subtitle-item:hover { background-color: rgba(255, 255, 255, 0.10) !important; }\n                `),\n                tray.div([\n                    tray.div([\n                        tray.flex([\n                            tray.stack([\n                                tray.text(\"Subtitle Engine\", { style: { fontSize: \"18px\", fontWeight: \"700\", color: \"#FFF\" } }),\n                                tray.text(\"Powered by Wyzie\", { style: { fontSize: \"11px\", opacity: 0.5 } })\n                            ]),\n                            isSearching.get() \n                                ? tray.badge(\"Syncing Providers...\", { intent: \"warning\" }) \n                                : tray.badge(`${subs.length} items found`, { intent: subs.length \u003e 0 ? \"success\" : \"gray\" })\n                        ], { justifyContent: \"space-between\", alignItems: \"center\" })\n                    ], { style: { padding: \"20px 20px 15px 20px\" } }),\n\n                    tray.stack([\n                        tray.flex([\n                            !integrated \u0026\u0026 tray.input({ label: \"IMDB/TMDB ID\", fieldRef: imdbRef, style: { flex: 2 } }),\n                            !integrated \u0026\u0026 tray.input({ label: \"S\", fieldRef: seasonRef, style: { width: \"55px\" } }),\n                            !integrated \u0026\u0026 tray.input({ label: \"E\", fieldRef: episodeRef, style: { width: \"55px\" } }),\n                            !integrated \u0026\u0026 tray.button({ \n                                label: \"Search\", \n                                onClick: \"triggerManualSearch\", \n                                intent: isSearching.get() ? \"gray\" : \"white-subtle\",\n                                disabled: isSearching.get() || !imdbRef.current,\n                                style: { marginTop: \"24px\", height: \"38px\" } \n                            })\n                        ].filter(Boolean), { gap: 1 }),\n\n                        tray.flex([\n                            tray.select(\"Source\", {\n                                fieldRef: sourceRef,\n                                onChange: \"update\",\n                                options: [\n                                  { label: \"AnimeTosho (Integrated)\", value: \"animetoshoSource\" },\n                                  { label: \"AnimeTosho\", value: \"animetosho\" },\n                                  { label: \"SubDL\", value: \"subdl\" },\n                                  { label: \"Subf2m\", value: \"subf2m\" },\n                                  { label: \"OpenSubtitles\", value: \"opensubtitles\" },\n                                  { label: \"Podnapisi\", value: \"podnapisi\" },\n                                  { label: \"Gestdown\", value: \"gestdown\" }\n                                ],\n                                style: { flex: 1 }\n                            }),\n                            tray.select(\"Language\", {\n                                fieldRef: langRef,\n                                onChange: \"filter\",\n                                options: [\n                                    { label: \"All\", value: \"all\" },\n                                    { label: \"English\", value: \"en\" },\n                                    { label: \"Spanish (ES)\", value: \"es\" },\n                                    { label: \"Spanish (LA)\", value: \"ea\" },\n                                    { label: \"French\", value: \"fr\" },\n                                    { label: \"German\", value: \"de\" },\n                                    { label: \"Italian\", value: \"it\" },\n                                    { label: \"Portuguese (PT)\", value: \"pt\" },\n                                    { label: \"Portuguese (BR)\", value: \"pb\" },\n                                    { label: \"Japanese\", value: \"ja\" },\n                                    { label: \"Korean\", value: \"ko\" },\n                                    { label: \"Chinese (Simplified)\", value: \"zh\" },\n                                    { label: \"Chinese (Traditional)\", value: \"zt\" },\n                                    { label: \"Russian\", value: \"ru\" },\n                                    { label: \"Arabic\", value: \"ar\" },\n                                    { label: \"Turkish\", value: \"tr\" },\n                                    { label: \"Indonesian\", value: \"id\" },\n                                    { label: \"Vietnamese\", value: \"vi\" },\n                                    { label: \"Thai\", value: \"th\" },\n                                    { label: \"Hindi\", value: \"hi\" },\n                                    { label: \"Bengali\", value: \"bn\" },\n                                    { label: \"Malay\", value: \"ms\" },\n                                    { label: \"Tagalog\", value: \"tl\" },\n                                    { label: \"Persian\", value: \"fa\" },\n                                    { label: \"Hebrew\", value: \"he\" },\n                                    { label: \"Polish\", value: \"pl\" },\n                                    { label: \"Dutch\", value: \"nl\" },\n                                    { label: \"Greek\", value: \"el\" },\n                                    { label: \"Czech\", value: \"cs\" },\n                                    { label: \"Hungarian\", value: \"hu\" },\n                                    { label: \"Romanian\", value: \"ro\" },\n                                    { label: \"Swedish\", value: \"sv\" },\n                                    { label: \"Danish\", value: \"da\" },\n                                    { label: \"Finnish\", value: \"fi\" },\n                                    { label: \"Norwegian\", value: \"no\" },\n                                    { label: \"Ukrainian\", value: \"uk\" },\n                                    { label: \"Bulgarian\", value: \"bg\" },\n                                    { label: \"Slovak\", value: \"sk\" },\n                                    { label: \"Croatian\", value: \"hr\" },\n                                    { label: \"Serbian\", value: \"sr\" },\n                                    { label: \"Slovenian\", value: \"sl\" },\n                                    { label: \"Lithuanian\", value: \"lt\" },\n                                    { label: \"Latvian\", value: \"lv\" },\n                                    { label: \"Estonian\", value: \"et\" },\n                                    { label: \"Icelandic\", value: \"is\" },\n                                    { label: \"Albanian\", value: \"sq\" },\n                                    { label: \"Armenian\", value: \"hy\" },\n                                    { label: \"Azerbaijani\", value: \"az\" },\n                                    { label: \"Basque\", value: \"eu\" },\n                                    { label: \"Belarusian\", value: \"be\" },\n                                    { label: \"Bosnian\", value: \"bs\" },\n                                    { label: \"Catalan\", value: \"ca\" },\n                                    { label: \"Galician\", value: \"gl\" },\n                                    { label: \"Georgian\", value: \"ka\" },\n                                    { label: \"Gujarati\", value: \"gu\" },\n                                    { label: \"Kazakh\", value: \"kk\" },\n                                    { label: \"Khmer\", value: \"km\" },\n                                    { label: \"Macedonian\", value: \"mk\" },\n                                    { label: \"Malayalam\", value: \"ml\" },\n                                    { label: \"Marathi\", value: \"mr\" },\n                                    { label: \"Mongolian\", value: \"mn\" },\n                                    { label: \"Nepali\", value: \"ne\" },\n                                    { label: \"Punjabi\", value: \"pa\" },\n                                    { label: \"Sinhala\", value: \"si\" },\n                                    { label: \"Tamil\", value: \"ta\" },\n                                    { label: \"Telugu\", value: \"te\" },\n                                    { label: \"Urdu\", value: \"ur\" },\n                                    { label: \"Uzbek\", value: \"uz\" },\n                                    { label: \"Welsh\", value: \"cy\" }\n                                ],\n                                style: { flex: 1 }\n                            }),\n                            tray.select(\"Format\", {\n                                fieldRef: formatRef,\n                                onChange: \"filter\",\n                                options: [\n                                  { label: \"All\", value: \"all\" },\n                                  { label: \"ASS\", value: \"ass\" },\n                                  { label: \"SSA\", value: \"ssa\" },\n                                  { label: \"SRT\", value: \"srt\" },\n                                  { label: \"VTT\", value: \"vtt\" }\n                                ],\n                                style: { flex: 1 }\n                            })\n                        ], { gap: 1 }),\n\n                        tray.flex([\n                            tray.switch(\"Closed Captions (CC)\", { fieldRef: hiRef, onChange: \"filter\" }),\n                            integrated \u0026\u0026 tray.switch(\"Sign/Song\", { fieldRef: signRef, onChange: \"filter\" }),\n                            integrated \u0026\u0026 tray.switch(\"Honorifics\", { fieldRef: honorRef, onChange: \"filter\" }),\n                        ].filter(Boolean), { padding: \"4px 0\" })\n                    ], { style: { padding: \"0 20px 20px 20px\", borderBottom: \"3px solid rgba(255,255,255,0.08)\" }, gap: 1.2 }),\n\n                    tray.div([\n                        isSearching.get() ? \n                            tray.div([tray.text(\"Searching...\", { style: { textAlign: \"center\", padding: \"60px\", opacity: 0.5 } })]) : \n                        subs.length === 0 ?\n                            tray.stack([\n                                (activeSession.get() \u0026\u0026 [\"es\", \"ea\", \"pb\", \"pt\", \"zh\", \"zt\"].includes(langRef.current)) \u0026\u0026 !integrated ?\n                                    tray.alert({\n                                        title: \"Smart Tip\",\n                                        description: \n                                            langRef.current === \"es\" ? \"Try switching to Spanish (LA). It might contain Spanish (ES).\" :\n                                            langRef.current === \"ea\" ? \"Try switching to Spanish (ES). It might contain Spanish (LA).\" :\n                                            langRef.current === \"pb\" ? \"Try switching to Portuguese (PT). It might contain Portuguese (BR).\" :\n                                            langRef.current === \"pt\" ? \"Try switching to Portuguese (BR). It might contain Portuguese (PT).\" :\n                                            langRef.current === \"zt\" ? \"Try switching to Chinese (Traditional). It might contain Chinese (Simplified)\" :\n                                            \"Try switching to Chinese (Simplified). It might contain Chinese (Traditional).\",\n                                        intent: \"info\",\n                                        style: { margin: \"20px 20px 0px 20px\" }\n                                    }) : tray.div([]),\n                        \n                                activeSession.get() ? \n                                    tray.alert({\n                                        title: \"No Results\",\n                                        description: \"Try changing your search parameters or source.\",\n                                        intent: \"warning\",\n                                        style: { margin: \"20px\" }\n                                    }) : \n                                    tray.alert({\n                                        title: \"No Active Session Found\",\n                                        description: \"Subtitle Engine is only compatible with Seanime's built-in player. Please start a video for auto search, or enter an ID manually.\",\n                                        intent: \"warning\",\n                                        style: { margin: \"20px\" }\n                                    })\n                            ]) :\n                        tray.stack(subs.map((sub, i) =\u003e {\n                            const isThisSelected = currentlySelectedList.includes(sub.url);\n\n                            return tray.flex([\n                                tray.stack([\n                                    tray.text(sub.release, { style: { fontSize: \"15px\", fontWeight: \"600\", color: \"#efefef\" }, maxLines: 1 }),\n                                    tray.flex([\n                                        tray.flex([\n                                            tray.img(sub.flagUrl, { style: { width: \"18px\", height: \"12px\", borderRadius: \"1px\", objectFit: \"cover\", flexShrink: 0 } }),\n                                            tray.text(`${sub.display.toUpperCase()} (${sub.language.toUpperCase()})`, { \n                                                style: { fontSize: \"12px\", fontWeight: \"700\", color: \"rgba(255,255,255,0.9)\", whiteSpace: \"nowrap\", lineHeight: \"12px\", marginTop: \"0.5px\" } \n                                            })\n                                        ], { gap: 0.6, alignItems: \"center\", style: { backgroundColor: \"rgba(255,255,255,0.12)\", padding: \"2px 8px\", borderRadius: \"100px\", border: \"1px solid rgba(255,255,255,0.2)\", height: \"18px\", flexShrink: 0 } }),\n                                        sub.isCR \u0026\u0026 tray.badge(\"CR\", { intent: \"warning\", size: \"sm\" }),\n                                        sub.isNF \u0026\u0026 tray.badge(\"NF\", { intent: \"alert\", size: \"sm\" }),\n                                        tray.badge(sub.format.toUpperCase(), { intent: \"primary\", size: \"sm\" }),\n                                        sub.isHearingImpaired \u0026\u0026 tray.badge(\"CC\", { intent: \"info\", size: \"sm\" }),\n                                        sub.isSignSongs \u0026\u0026 tray.badge(\"Sign/Song\", { intent: \"info\", size: \"sm\" }),\n                                        sub.isHonorifics \u0026\u0026 tray.badge(\"Honorifics\", { intent: \"info\", size: \"sm\" }),\n                                        tray.text(`• ${sub.source}`, { style: { fontSize: \"11px\", opacity: 0.4, marginLeft: \"2px\" } })\n                                    ].filter(Boolean), { gap: 0.8, alignItems: \"center\" })\n                                ], { style: { flex: 1 }, gap: 0.5 }),\n\n                                tray.button({\n                                    label: isThisSelected ? \"Added\" : \"Select\",\n                                    size: \"sm\",\n                                    intent: isThisSelected ? \"gray\" : \"primary\",\n                                    disabled: isThisSelected,\n                                    onClick: ctx.eventHandler(`inject-${i}`, () =\u003e injectSubtitle(sub))\n                                })\n                            ], { \n                                className: \"subtitle-item\",\n                                style: { padding: \"14px 20px\", borderBottom: \"3px solid rgba(255,255,255,0.08)\", alignItems: \"center\", marginTop: i === 0 ? \"8px\" : \"0\" } \n                            })\n                        }))\n                    ])\n                ], { style: { display: \"flex\", flexDirection: \"column\", height: \"100%\" } })\n            ], { style: { width: \"100%\", height: \"100%\" } })\n        })\n    })\n}",
  "userConfig": {
    "version": 2,
    "requiresConfig": false,
    "fields": [
      {
        "type":"select",
        "name":"autoSelect",
        "label":"Auto Select",
        "options":[
          { "value": "none", "label": "None" },
          { "value": "auto", "label": "Auto Select" },
          { "value": "smart", "label": "Smart Select" }
        ],
        "default":"none"
      },
      {
        "type": "select",
        "name": "source",
        "label": "Source",
        "options": [
          { "value": "animetoshoSource", "label": "AnimeTosho (Integrated)" },
          { "value": "animetosho", "label": "AnimeTosho" },
          { "value": "subdl", "label": "SubDL" },
          { "value": "subf2m", "label": "Subf2m" },
          { "value": "opensubtitles", "label": "OpenSubtitles" },
          { "value": "podnapisi", "label": "Podnapisi" },
          { "value": "gestdown", "label": "Gestdown" }
        ],
        "default": "animetoshoSource"
      },
      {
        "type": "select",
        "name": "language",
        "label": "Language",
        "options": [
          { "label": "All", "value": "all" },
          { "label": "English", "value": "en" },
          { "label": "Spanish (ES)", "value": "es" },
          { "label": "Spanish (LA)", "value": "ea" },
          { "label": "French", "value": "fr" },
          { "label": "German", "value": "de" },
          { "label": "Italian", "value": "it" },
          { "label": "Portuguese (PT)", "value": "pt" },
          { "label": "Portuguese (BR)", "value": "pb" },
          { "label": "Japanese", "value": "ja" },
          { "label": "Korean", "value": "ko" },
          { "label": "Chinese (Simplified)", "value": "zh" },
          { "label": "Chinese (Traditional)", "value": "zt" },
          { "label": "Russian", "value": "ru" },
          { "label": "Arabic", "value": "ar" },
          { "label": "Turkish", "value": "tr" },
          { "label": "Indonesian", "value": "id" },
          { "label": "Vietnamese", "value": "vi" },
          { "label": "Thai", "value": "th" },
          { "label": "Hindi", "value": "hi" },
          { "label": "Bengali", "value": "bn" },
          { "label": "Malay", "value": "ms" },
          { "label": "Tagalog", "value": "tl" },
          { "label": "Persian", "value": "fa" },
          { "label": "Hebrew", "value": "he" },
          { "label": "Polish", "value": "pl" },
          { "label": "Dutch", "value": "nl" },
          { "label": "Greek", "value": "el" },
          { "label": "Czech", "value": "cs" },
          { "label": "Hungarian", "value": "hu" },
          { "label": "Romanian", "value": "ro" },
          { "label": "Swedish", "value": "sv" },
          { "label": "Danish", "value": "da" },
          { "label": "Finnish", "value": "fi" },
          { "label": "Norwegian", "value": "no" },
          { "label": "Ukrainian", "value": "uk" },
          { "label": "Bulgarian", "value": "bg" },
          { "label": "Slovak", "value": "sk" },
          { "label": "Croatian", "value": "hr" },
          { "label": "Serbian", "value": "sr" },
          { "label": "Slovenian", "value": "sl" },
          { "label": "Lithuanian", "value": "lt" },
          { "label": "Latvian", "value": "lv" },
          { "label": "Estonian", "value": "et" },
          { "label": "Icelandic", "value": "is" },
          { "label": "Albanian", "value": "sq" },
          { "label": "Armenian", "value": "hy" },
          { "label": "Azerbaijani", "value": "az" },
          { "label": "Basque", "value": "eu" },
          { "label": "Belarusian", "value": "be" },
          { "label": "Bosnian", "value": "bs" },
          { "label": "Catalan", "value": "ca" },
          { "label": "Galician", "value": "gl" },
          { "label": "Georgian", "value": "ka" },
          { "label": "Gujarati", "value": "gu" },
          { "label": "Kazakh", "value": "kk" },
          { "label": "Khmer", "value": "km" },
          { "label": "Macedonian", "value": "mk" },
          { "label": "Malayalam", "value": "ml" },
          { "label": "Marathi", "value": "mr" },
          { "label": "Mongolian", "value": "mn" },
          { "label": "Nepali", "value": "ne" },
          { "label": "Punjabi", "value": "pa" },
          { "label": "Sinhala", "value": "si" },
          { "label": "Tamil", "value": "ta" },
          { "label": "Telugu", "value": "te" },
          { "label": "Urdu", "value": "ur" },
          { "label": "Uzbek", "value": "uz" },
          { "label": "Welsh", "value": "cy" }
        ],
        "default": "all"
      },
      {
        "type": "select",
        "name": "format",
        "label": "Format",
        "options": [
          { "value": "all", "label": "All" },
          { "value": "ass", "label": "ASS" },
          { "value": "ssa", "label": "SSA" },
          { "value": "srt", "label": "SRT" },
          { "value": "vtt", "label": "VTT" }
        ],
        "default": "all"
      },
      {
        "type": "switch",
        "name": "hi",
        "label": "Closed Caption (CC)",
        "default": "false"
      },
      {
        "type": "switch",
        "name": "signSong",
        "label": "Sign/Song (Integrated Source)",
        "default": "false"
      },
      {
        "type": "switch",
        "name": "honorifics",
        "label": "Honorifics (Integrated Source)",
        "default": "false"
      },
      {
        "type":"select",
        "name":"speed",
        "label":"Prioritize Speed (Integrated Source)",
        "options":[
          { "value": "veryfast", "label": "Veryfast" },
          { "value": "fast", "label": "Fast" },
          { "value": "medium", "label": "Medium" }
        ],
        "default":"fast"
      },
      {
        "type": "select",
        "name": "method",
        "label": "ID Mapping Method (Fallback)",
        "options": [
          { "value": "1", "label": "Method 1 (Github)" },
          { "value": "2", "label": "Method 2 (Third Party Site)" }
        ],
        "default": "1"
      }
    ]
  },
  "plugin": {
    "version": "1",
    "permissions": {
      "scopes": ["playback"],
      "allow": {
        "networkAccess": {
          "allowedDomains": [
            "https://feed.animetosho.org",
            "https://sub.wyzie.ru",
            "https://ramregar97-idmapper.hf.space"
          ],
          "reasoning": "Fetch subtitles"
        }
      }
    }
  }
}
